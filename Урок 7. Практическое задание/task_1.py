"""
Задание 1.

Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.

Обязательно сделайте замеры времени обеих реализаций и дайте ответ помогла ли
доработка и в каких случаях она будет эффективной.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.
"""

from timeit import timeit


def sort(lst):
    a = lst[:]
    i = 0
    n = len(a)
    while i < n - 1:

        j = 0
        while j < n - 1 - i:
            if a[j] < a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
            j += 1
        i += 1
    return a


def sort_mod(lst):
    a = lst[:]
    i = 0
    n = len(a)
    while i < n - 1:
        check = False
        j = 0
        while j < n - 1 - i:
            if a[j] < a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                check = True
            j += 1
        i += 1
        if not check:
            # print('исходный список отсортирован')
            return a
    return a


ls = [-99, -49, 33, 4, 38, -16, -46, 93, -27, 3, 86, 89, 81, -83, 78, -67, 70, 55, -65, 20, 90]

print(f'Исходный список: {ls}')
print(f'Отсортированный список: {sort_mod(ls)}')
setup_str = "ls = [-99, -49, 33, 4, 38, -16, -46, 93, -27, 3, 86, 89, 81, -83, 78, -67, 70, 55, -65, 20, 90]"
setup_str1 = "ls = [93, 90, 89, 86, 81, 78, 70, 55, 38, 33, 20, 4, 3, -16, -27, -46, -49, -65, -67, -83, -99]"

print(f"Сортировка несортированного списка - {timeit(stmt='sort(ls)', setup=setup_str, number=1000, globals=globals())}")
print(f"Модифицированная сортировка несортированного списка - {timeit(stmt='sort_mod(ls)', setup=setup_str, number=1000, globals=globals())}")
print(f"Сортировка сортированного списка - {timeit(stmt='sort(ls)', setup=setup_str1, number=1000, globals=globals())}")
print(f"Модифицированная сортировка сортированного списка - {timeit(stmt='sort_mod(ls)', setup=setup_str1, number=1000, globals=globals())}")

# Сортировка несортированного списка - 0.14293830000000002
# Модифицированная сортировка несортированного списка - 0.1432255
# Сортировка сортированного списка - 0.09437999999999996
# Модифицированная сортировка сортированного списка - 0.00885649999999999

# судя по замерам, модификация алгоритма сортировки действительно может ускорить процесс,
# но для больших списков. Если список изначально отсортирован, то алгоритм позволяет за один проход определить
# это. Таким образом снижая теоретическую сложность О(n^2) до O(n). На малых списках эта разница будет незаметна.
